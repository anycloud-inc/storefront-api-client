/*! shopify/storefront-api-client -- Copyright (c) 2023-present, Shopify Inc. -- license (MIT): https://github.com///github/blob/main/LICENSE */
!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?r(exports):"function"==typeof define&&define.amd?define(["exports"],r):r((e="undefined"!=typeof globalThis?globalThis:e||self).ShopifyStorefrontAPIClient={})}(this,(function(e){"use strict";const r="GraphQL Client",t=0,n=3;function o(e){return e instanceof Error?e.message:JSON.stringify(e)}function s({client:e,retries:r}){if(void 0!==r&&("number"!=typeof r||r<t||r>n))throw new Error(`${e}: The provided "retries" value (${r}) is invalid - it cannot be less than ${t} or greater than ${n}`)}const i=`${r}: An error occurred while fetching from the API. Review 'graphQLErrors' for details.`,a=`${r}: Response returned unexpected Content-Type:`,c={json:"application/json",multipart:"multipart/mixed"},u=1e3,p=[429,503];function l({headers:e,url:t,fetchApi:n=g,retries:l=0,logger:d}){s({client:r,retries:l});const f={headers:e,url:t,retries:l},h=function(e){return r=>{e&&e(r)}}(d),m=function(e,t){const n=async(s,i,a)=>{const c=i+1,l=a+1;let d;try{if(d=await e(...s),t({type:"HTTP-Response",content:{requestParams:s,response:d}}),!d.ok&&p.includes(d.status)&&c<=l)throw new Error;return d}catch(e){if(c<=l)return await async function(e){return new Promise((r=>setTimeout(r,e)))}(u),t({type:"HTTP-Retry",content:{requestParams:s,lastResponse:d,retryAttempt:i,maxRetries:a}}),n(s,c,a);throw new Error(`${r}:${a>0?` Attempted maximum number of ${a} network retries. Last message -`:""} ${o(e)}`)}};return n}(n,h),g=function(e,{url:t,headers:n,retries:o}){return async(i,a={})=>{const{variables:c,headers:u,url:p,retries:l}=a,d=JSON.stringify({query:i,variables:c});s({client:r,retries:l});const f=[p??t,{method:"POST",headers:{...n,...u},body:d}];return e(f,1,l??o)}}(m,f),$=function(e){return async(...t)=>{try{const n=await e(...t),{status:o,statusText:s}=n,u=n.headers.get("content-type")||"";return n.ok?u.includes(c.json)?async function(e){const{errors:t,data:n,extensions:o}=await e.json();return{...n?{data:n}:{},...o?{extensions:o}:{},...t||!n?{errors:{networkStatusCode:e.status,message:t?i:`${r}: An unknown error has occurred. The API did not return a data object or any errors in its response.`,...t?{graphQLErrors:t}:{}}}:{}}}(n):{errors:{networkStatusCode:o,message:`${a} ${u}`}}:{errors:{networkStatusCode:o,message:s}}}catch(e){return{errors:{message:o(e)}}}}}(g);return{config:f,fetch:g,request:$}}function d({client:e,currentSupportedApiVersions:r,apiVersion:t,logger:n}){const o=`${e}: the provided apiVersion ("${t}")`,s=`Current supported API versions: ${r.join(", ")}`;if(!t||"string"!=typeof t)throw new Error(`${o} is invalid. ${s}`);const i=t.trim();r.includes(i)||(n?n({type:"UNSUPPORTED_API_VERSION",content:{apiVersion:t,supportedApiVersions:r}}):console.warn(`${o} is deprecated or not supported. ${s}`))}function f(e){const r=3*e-2;return 10===r?r:`0${r}`}function h(e,r,t){const n=r-t;return n<=0?`${e-1}-${f(n+4)}`:`${e}-${f(n)}`}function m(){const{year:e,quarter:r,version:t}=function(){const e=new Date,r=e.getUTCMonth(),t=e.getUTCFullYear(),n=Math.floor(r/3+1);return{year:t,quarter:n,version:`${t}-${f(n)}`}}(),n=4===r?`${e+1}-01`:`${e}-${f(r+1)}`;return[h(e,r,3),h(e,r,2),h(e,r,1),t,n,"unstable"]}const g="application/json",$="Storefront API Client";e.createStorefrontApiClient=function({storeDomain:e,apiVersion:r,publicAccessToken:t,privateAccessToken:n,clientName:o,retries:s=0,customFetchApi:i,logger:a}){const c=m(),u=function({client:e,storeDomain:r}){try{if(!r||"string"!=typeof r)throw new Error;const e=r.trim(),t=e.startsWith("http")?e:`https://${e}`,n=new URL(t);return n.protocol="https",n.origin}catch(t){throw new Error(`${e}: a valid store domain ("${r}") must be provided`)}}({client:$,storeDomain:e}),p={client:$,currentSupportedApiVersions:c,logger:a};d({...p,apiVersion:r}),function(e,r){if(!e&&!r)throw new Error(`${$}: a public or private access token must be provided`);if(e&&r)throw new Error(`${$}: only provide either a public or private access token`)}(t,n),function(e){if(e)throw new Error(`${$}: private access tokens and headers should only be used in a server-to-server implementation. Use the public API access token in nonserver environments.`)}(n);const f=function(e,r,t){return n=>{n&&d({...t,apiVersion:n});const o=(n??r).trim();return`${e}/api/${o}/graphql.json`}}(u,r,p),h={storeDomain:u,apiVersion:r,...t?{publicAccessToken:t}:{privateAccessToken:n},headers:{"Content-Type":g,Accept:g,"X-SDK-Variant":"storefront-api-client","X-SDK-Version":"0.0.1",...o?{"X-SDK-Variant-Source":o}:{},...t?{"X-Shopify-Storefront-Access-Token":t}:{"Shopify-Storefront-Private-Token":n}},apiUrl:f(),clientName:o},w=l({headers:h.headers,url:h.apiUrl,retries:s,fetchApi:i,logger:a}),y=function(e){return r=>({...r??{},...e.headers})}(h),v=function(e,r){return t=>t?r(t):e.apiUrl}(h,f),A=function({getHeaders:e,getApiUrl:r}){return(t,n)=>{const o=[t];if(n){const{variables:t,apiVersion:s,customHeaders:i,retries:a}=n;o.push({variables:t,headers:i?e(i):void 0,url:s?r(s):void 0,retries:a})}return o}}({getHeaders:y,getApiUrl:v}),b={config:h,getHeaders:y,getApiUrl:v,fetch:(...e)=>{const r=A(...e);return w.fetch(...r)},request:(...e)=>{const r=A(...e);return w.request(...r)}};return Object.freeze(b)}}));
//# sourceMappingURL=storefront-api-client.min.js.map
